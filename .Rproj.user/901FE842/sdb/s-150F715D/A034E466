{
    "collab_server" : "",
    "contents" : "#' Read GENEPOP format input file\n#'\n#' This function allows you to import a GENEPOP format file into R. Population names can be specified in the argument. See http://genepop.curtin.edu.au/help_input.html for details about GENEPOP format.\n#' @param x The GENEPOP file name or path to the file. The filename extension should be included.\n#' @param pop.names A character string vector for population names. The order of the name should be the same with the order (top to down) in your GENEPOP file.\n#' @return This function returns a list that comprises three items. [[1]] A matrix of genetic data with a population name label ($popNameVector) in the last column. [[2]] A vector of sample ID. [[3]] A vector of locus name.\n#' @examples infile <- read.genpop(\"Your_Genepop_File.txt\", pop.names=c(\"pop_A\", \"pop_B\", \"pop_C\"))\n#' @references Rousset, F., 2008. Genepop'007: a complete reimplementation of the Genepop software for Windows and Linux. Mol. Ecol. Resources 8: 103-106.\n#' @export\n#'\nread.genpop <- function(x, pop.names = NULL){\n  df <- readLines(x)\n  df <- df[-1]#skip the first line file info\n  popIndex <- grep(\"pop\",df,ignore.case=TRUE)\n  noPops <- length(popIndex)\n  if(length(pop.names)==0){ #check if pop.names is specified, if not, assign pop names\n    pop.names <- paste0(\"pop.\",seq_along(1:noPops))\n  } else if(length(pop.names)>0){ #check if pop.names and number of pop match\n    if(!length(pop.names)==noPops){\n      cat(\"\\nError: Pop.names and number of pop in data not match...\")\n      break } }\n\n  #Extract locus name, save locus names in vector \"locusNames\"\n  if (popIndex[1] == 2) {\n    locusNames <- str_trim(df[1],side=\"both\")\n    locusNames <- strsplit(locusNames,\",\")[[1]]\n  } else if (popIndex[1] > 2) {\n    index <- popIndex[1] - 1\n    locusNames <- df[1:index]\n  }\n  locusNames <- str_trim(locusNames,side=\"both\")\n  noLocus <- length(locusNames)\n\n  #Get index for individuals and save in a nested list \"pop_all\"\n  for (i in 1:noPops){\n    if (i < noPops){\n      start <- popIndex[i] + 1; end <- popIndex[i+1] - 1\n      assign(paste0(\"pop_\",i,\"_index\"), start : end, env = .GlobalEnv )\n    } else if (i == noPops){\n      start <- popIndex[i] + 1; end <- length(df)\n      assign(paste0(\"pop_\",i,\"_index\"), start : end, env = .GlobalEnv)\n    }\n  }\n  pop_all <- lapply(paste0(\"pop_\", seq_along(1:noPops),\"_index\"), FUN = get)\n\n  #save individual index in one vector \"ind_all_index\"\n  ind_all_index <- NULL\n  for (i in 1:noPops){\n    ind_all_index <- c(ind_all_index, pop_all[[i]])\n  }\n  noInds <- length(ind_all_index)\n\n  #extract individual data\n  ind_df <- df[ind_all_index]\n  #split individual ID and genotype data\n  id_vector <- NULL\n  geno_list <- list()\n  for(i in 1:noInds){\n    id_n_genotype <- strsplit(ind_df[i],\",\")[[1]]\n    id <- str_trim(id_n_genotype[1], side=\"both\")\n    id_vector <- c(id_vector,id)\n    geno <- str_trim(id_n_genotype[2], side=\"both\")\n    geno <- gsub(\"\\\\s+\",\" \",geno)#clean extra space or change tabs to one single space between loci\n    geno <- strsplit(geno,\" \")[[1]]#make each locus an element\n    geno <- list(geno)\n    geno_list <- c(geno_list, geno)\n  }\n\n  #Get alleles of each locus across individuals\n  #create an empty data frame\n  genoMatrix <- data.frame(matrix(ncol=0,nrow=noInds))\n  #Setup progress bar\n  pb <- txtProgressBar(min = 0, max = noLocus, style = 3)\n  #Save missing locus index in a vector\n  missLocusIndex <- NULL\n  for(m in 1:noLocus){\n    oneLocus_vector <- NULL\n    setTxtProgressBar(pb, m)\n    for(n in 1:noInds){\n      eachlocus <- geno_list[[n]][m]\n      noChar <- nchar(eachlocus)\n      diploid <- substring(eachlocus, c(1,(noChar/2)+1), c(noChar/2,noChar))\n      oneLocus_vector <- union(oneLocus_vector, diploid)\n    }\n    oneLocus_vector <- sort(oneLocus_vector)\n    #remove \"00\" or \"000\" data\n    oneLocus_vector <- oneLocus_vector[! oneLocus_vector %in% \"00\"]\n    oneLocus_vector <- oneLocus_vector[! oneLocus_vector %in% \"000\"]\n    #create multi variables for locus\n    noVarOfLocus <- length(oneLocus_vector)\n    locusDf <- data.frame(matrix(ncol=noVarOfLocus, nrow=0))\n\n    #check if a locus is a missing data across individuals, if so, save the locus index\n    if(noVarOfLocus==0){\n      missLocusIndex <- c(missLocusIndex,m)\n    }\n    noMissLocusIndex <- length(missLocusIndex)\n    #check individual genotype and convert genotype data to binary-like\n    for(p in 1:noInds){\n      eachlocus <- geno_list[[p]][m]\n      noChar <- nchar(eachlocus)#count number of character (usually either 4 or 6 digits)\n      diploid <- substring(eachlocus, c(1,(noChar/2)+1), c(noChar/2,noChar))\n      binaryVector <- oneLocus_vector %in% diploid\n      #count number of TRUE\n      noTrue <- table(binaryVector)[\"TRUE\"]\n      noTrue[is.na(noTrue)] <- 0\n      if(noTrue==1){ #if there is only one TRUE, meaning a homozygote\n        binaryVector <- binaryVector*1\n      } else {\n        binaryVector <- binaryVector*0.5\n      }\n      locusDf <- rbind(locusDf,binaryVector)\n    }\n    if(!noVarOfLocus==0){\n      names(locusDf) <- paste0(locusNames[m],\"_\",seq_along(1:noVarOfLocus))\n      genoMatrix <- cbind(genoMatrix,locusDf)\n    }\n  }\n  #count number of columns (alleles) in genetic data matrix\n  noLociVar <- ncol(genoMatrix)\n  #Remove locus name if it's missing data across individuals\n  if(!noMissLocusIndex==0){\n    locusNames <- locusNames[-missLocusIndex]\n  }\n  #close progrss bar\n  close(pb)\n  #Create pop name vector and concatenate to the genoMatrix\n  popNames_vector <- NULL\n  for (i in 1:noPops){\n    popsize <- length(pop_all[[i]])\n    popNameVector <- rep(pop.names[i], popsize)\n    popNames_vector <- c(popNames_vector, popNameVector)\n  }\n  genoMatrix <- cbind(genoMatrix, popNames_vector)\n\n  #Print some message to console\n  cat(\"\\n  ############### assingPOP v2.0 ###############\\n\")\n  cat(\"\\n  A GENEPOP format file was successfully imported!\\n\")\n  cat(paste0(\"\\n  DataInfo: \",noInds,\" obs. by \",noLocus,\" loci (with \",noLociVar,\" var.)\"))\n  cat(paste0(\"\\n  DataMatrix: \",nrow(genoMatrix),\" rows by \",ncol(genoMatrix), \" columns\"))\n  cat(paste0(\"\\n  Number of pop: \",noPops))\n  for(i in 1:noPops){\n    popSize <- length(get(paste0(\"pop_\",i,\"_index\")))\n    cat(paste0(\"\\n  Number of inds (\",pop.names[i],\"): \",popSize ) )\n  }\n  cat(\"\\n\")\n  cat(\"\\n  Data output in a list comprising the following three elements:\")\n  cat(\"\\n  DataMatrix @ YOUR_LIST_NAME[[1]]\")\n  cat(\"\\n  IndividualNames @ YOUR_LIST_NAME[[2]]\")\n  cat(\"\\n  LocusNames @ YOUR_LIST_NAME[[3]]\")\n  cat(\"\\n\\n\")\n  #Remove variables from GlobalEnv.\n  rm(list = ls(pattern=\"_index\", envir = .GlobalEnv), envir = .GlobalEnv)\n\n  return(list(genoMatrix, id_vector, locusNames))\n}\n",
    "created" : 1465936256602.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1017600927",
    "id" : "A034E466",
    "lastKnownWriteTime" : 1465934881,
    "last_content_update" : 1465934881,
    "path" : "C:/Users/Alex/Dropbox/R programming/assignPOP/R/read.genpop.R",
    "project_path" : "R/read.genpop.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}